<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parallel Rigid Body Simulation (64x)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-radius: 4px;
            background-color: #222;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            min-width: 250px;
            backdrop-filter: blur(4px);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            margin-bottom: 5px;
            font-family: 'Courier New', monospace;
        }

        .label { color: #888; }
        .value { color: #fff; font-weight: bold; }

        #energy-graph {
            margin-top: 10px;
            width: 100%;
            height: 60px;
            background: #111;
            border: 1px solid #333;
            position: relative;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            display: flex;
            gap: 10px;
        }

        button {
            pointer-events: auto;
            background: #444;
            color: white;
            border: 1px solid #666;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            transition: background 0.2s;
        }

        button:hover { background: #555; }
        button:active { background: #4db8ff; border-color: #4db8ff; }

    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="stat-row">
            <span class="label">Systems Active:</span>
            <span class="value">64</span>
        </div>
        <div class="stat-row">
            <span class="label">Workers:</span>
            <span class="value" id="worker-count">0</span>
        </div>
        <div class="stat-row">
            <span class="label">Total Energy (Sum):</span>
            <span class="value" id="total-e">0.00</span>
        </div>
        <div class="stat-row">
            <span class="label">Avg Deviation:</span>
            <span class="value" id="deviation" style="color: #0f0">0.00%</span>
        </div>
        <canvas id="energy-graph"></canvas>
        
        <div id="overlay-stats" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #333;">
            <div class="stat-row">
                <span class="label">Avg Height (Y):</span>
                <span class="value" id="avg-y">0.0</span>
            </div>
            <div class="stat-row">
                <span class="label">Avg Displacement (X):</span>
                <span class="value" id="avg-x">0.0</span>
            </div>
            <div class="stat-row">
                <span class="label">Avg Distance:</span>
                <span class="value" id="avg-dist">0.0</span>
            </div>
        </div>
    </div>

    <canvas id="simCanvas"></canvas>

    <div class="controls">
        <button onclick="resetAll()">Reset Multiverse</button>
        <button onclick="toggleTrails()">Toggle Trails</button>
        <button onclick="toggleOverlay()">Toggle Overlay</button>
    </div>

<script>
/**
 * Parallel Precision Physics Engine with Web Workers
 * Simulates 64 independent rigid body systems across multiple CPU cores
 */

const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
const graphCanvas = document.getElementById('energy-graph');
const graphCtx = graphCanvas.getContext('2d', { desynchronized: true });

const workerCountEl = document.getElementById('worker-count');
const totalEEl = document.getElementById('total-e');
const deviationEl = document.getElementById('deviation');
const overlayStatsEl = document.getElementById('overlay-stats');
const avgXEl = document.getElementById('avg-x');
const avgYEl = document.getElementById('avg-y');
const avgDistEl = document.getElementById('avg-dist');

// --- Constants ---
const NUM_SYSTEMS = 64;
const CONTAINER_RADIUS = 300;
const BALL_RADIUS = 30;
const TWO_PI = Math.PI * 2;
const OVERLAY_ALPHA = Math.sqrt(1 / NUM_SYSTEMS);
const GRID_COLS = 8;
const GRID_ROWS = 8;
const STATE_STRIDE = 4; // ballX, ballY, ballAngle, containerAngle (must match worker)
const TRAIL_LENGTH = 200;
const UI_UPDATE_INTERVAL_MS = 1000 / 30;

// --- Worker Pool ---
const numWorkers = navigator.hardwareConcurrency || 4;
const workers = [];
const systemStates = Array(NUM_SYSTEMS).fill(null).map((_, i) => ({
    id: i,
    ball: {x: 0, y: -220, angle: 0},
    container: {angle: 0},
    trailX: new Float32Array(TRAIL_LENGTH),
    trailY: new Float32Array(TRAIL_LENGTH),
    trailHead: 0,
    trailSize: 0
}));

const trailColors = Array(NUM_SYSTEMS);
for (let i = 0; i < NUM_SYSTEMS; i++) {
    trailColors[i] = `hsl(${(i * 360 / NUM_SYSTEMS)}, 70%, 60%)`;
}

const gridCx = new Float32Array(NUM_SYSTEMS);
const gridCy = new Float32Array(NUM_SYSTEMS);
const drawCx = new Float32Array(NUM_SYSTEMS);
const drawCy = new Float32Array(NUM_SYSTEMS);
let cellW = 0;
let cellH = 0;
let overlayCenterX = 0;
let overlayCenterY = 0;
let lastUiUpdate = 0;

workerCountEl.textContent = String(numWorkers);

// Distribute systems across workers
const systemsPerWorker = Math.ceil(NUM_SYSTEMS / numWorkers);
for (let w = 0; w < numWorkers; w++) {
    const worker = new Worker('physics-worker.js');
    const startId = w * systemsPerWorker;
    const endId = Math.min(startId + systemsPerWorker, NUM_SYSTEMS);
    const systemIds = [];
    for (let i = startId; i < endId; i++) {
        systemIds.push(i);
    }
    
    worker.systemIds = systemIds;
    worker.stateBuffer = new ArrayBuffer(systemIds.length * STATE_STRIDE * 4);
    worker.onmessage = (e) => handleWorkerMessage(worker, e);
    worker.postMessage({ type: 'init', systemIds });
    workers.push(worker);
}

// Fixed timestep variables
let lastTime = performance.now();
let accumulator = 0;
const FIXED_DT = 1/180;
const MAX_FRAME_TIME = 0.25;

let showTrails = true;
let showOverlay = false;
let overlayTransition = 0;
let totalInitialEnergy = 0;
let currentTotalEnergy = 0;
let displayedTotalEnergy = 0;
let energyHistory = [];
let layoutScale = 1;
let overlayScale = 1;
let pendingUpdates = 0;
let initializedWorkers = 0;
let isReady = false;
let activeBatchId = 0;

function expectedWorkerBufferBytes(worker) {
    return worker.systemIds.length * STATE_STRIDE * 4;
}

function ensureWorkerBuffer(worker) {
    const expectedBytes = expectedWorkerBufferBytes(worker);
    if (!(worker.stateBuffer instanceof ArrayBuffer) || worker.stateBuffer.byteLength !== expectedBytes) {
        worker.stateBuffer = new ArrayBuffer(expectedBytes);
    }
    return worker.stateBuffer;
}

function handleWorkerMessage(worker, e) {
    const { type } = e.data;
    
    if (type === 'initialized') {
        initializedWorkers++;
        if (initializedWorkers === numWorkers) {
            isReady = true;
            resetAll();
            requestAnimationFrame(loop);
        }
        return;
    }

    if (type === 'updated' || type === 'reset') {
        const { batchId, buffer, totalEnergy } = e.data;

        // Always reclaim the worker's buffer (even for stale batches).
        if (buffer instanceof ArrayBuffer) {
            worker.stateBuffer = buffer;
        }

        // Ignore stale responses (e.g., reset issued mid-update).
        if (batchId !== activeBatchId) return;

        const isReset = type === 'reset';
        const floats = new Float32Array(worker.stateBuffer);
        const ids = worker.systemIds;
        for (let i = 0; i < ids.length; i++) {
            const id = ids[i];
            const base = i * STATE_STRIDE;
            const s = systemStates[id];
            s.ball.x = floats[base];
            s.ball.y = floats[base + 1];
            s.ball.angle = floats[base + 2];
            s.container.angle = floats[base + 3];

            // Prevent a "teleport" segment: drop any trail points sampled while reset was pending.
            if (isReset) {
                s.trailHead = 0;
                s.trailSize = 0;
            }
        }

        currentTotalEnergy += totalEnergy;
        pendingUpdates--;
        if (pendingUpdates === 0) {
            displayedTotalEnergy = currentTotalEnergy;
            if (type === 'reset') {
                // Reset energy is the initial energy baseline.
                totalInitialEnergy = displayedTotalEnergy;
            }
        }
    }
}

function lerp(a, b, t) {
    return a + (b - a) * t;
}

function clearTrails() {
    for (let i = 0; i < NUM_SYSTEMS; i++) {
        const s = systemStates[i];
        s.trailHead = 0;
        s.trailSize = 0;
    }
}

function pushTrailPoint(s, x, y) {
    const head = s.trailHead;
    s.trailX[head] = x;
    s.trailY[head] = y;

    const nextHead = head + 1;
    s.trailHead = nextHead === TRAIL_LENGTH ? 0 : nextHead;
    if (s.trailSize < TRAIL_LENGTH) s.trailSize++;
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    graphCanvas.width = graphCanvas.offsetWidth;
    graphCanvas.height = graphCanvas.offsetHeight;
    
    if (energyHistory.length > graphCanvas.width) {
        energyHistory = energyHistory.slice(energyHistory.length - graphCanvas.width);
    }
    
    cellW = canvas.width / GRID_COLS;
    cellH = canvas.height / GRID_ROWS;
    overlayCenterX = canvas.width * 0.5;
    overlayCenterY = canvas.height * 0.5;

    for (let i = 0; i < NUM_SYSTEMS; i++) {
        const col = i % GRID_COLS;
        const row = (i / GRID_COLS) | 0;
        gridCx[i] = col * cellW + cellW * 0.5;
        gridCy[i] = row * cellH + cellH * 0.5;
    }

    const cellUnitSize = (CONTAINER_RADIUS * 2) * 1.1;
    
    const scaleH = canvas.height / (GRID_ROWS * cellUnitSize);
    const scaleW = canvas.width / (GRID_COLS * cellUnitSize);
    layoutScale = Math.min(scaleH, scaleW) * 0.95;
    
    const overlayUnitSize = (CONTAINER_RADIUS * 2) * 1.05;
    const overlayScaleH = canvas.height / overlayUnitSize;
    const overlayScaleW = canvas.width / overlayUnitSize;
    overlayScale = Math.min(overlayScaleH, overlayScaleW) * 0.98;
}
window.addEventListener('resize', resize);
resize();

function resetAll() {
    activeBatchId++;
    pendingUpdates = numWorkers;
    currentTotalEnergy = 0;

    // Clear trails/history immediately (don't wait for worker replies).
    clearTrails();
    lastUiUpdate = 0;

    workers.forEach(worker => {
        const buffer = ensureWorkerBuffer(worker);
        worker.postMessage({ type: 'reset', batchId: activeBatchId, buffer }, [buffer]);
    });
    energyHistory = [];
}

function updateGraph(currentTotal) {
    if (!totalInitialEnergy) return;
    
    energyHistory.push(currentTotal);
    if (energyHistory.length > graphCanvas.width) energyHistory.shift();
    
    const w = graphCanvas.width;
    const h = graphCanvas.height;
    
    graphCtx.clearRect(0, 0, w, h);
    
    graphCtx.beginPath();
    graphCtx.strokeStyle = '#444';
    graphCtx.setLineDash([5, 5]);
    graphCtx.moveTo(0, h/2);
    graphCtx.lineTo(w, h/2);
    graphCtx.stroke();
    graphCtx.setLineDash([]);
    
    graphCtx.beginPath();
    graphCtx.strokeStyle = '#0f0';
    graphCtx.lineWidth = 2;
    const scale = 5000;
    
    for (let i = 0; i < energyHistory.length; i++) {
        const val = energyHistory[i];
        const diff = (val - totalInitialEnergy) / totalInitialEnergy;
        const y = (h/2) - (diff * (h/2) * scale);
        if(i===0) graphCtx.moveTo(i, y);
        else graphCtx.lineTo(i, y);
    }
    graphCtx.stroke();
}

function loop() {
    const currentTime = performance.now();
    let frameTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;
    
    if (frameTime > MAX_FRAME_TIME) frameTime = MAX_FRAME_TIME;
    
    accumulator += frameTime;
    
    while (accumulator >= FIXED_DT) {
        // Don't send updates while waiting for responses (reset or update)
        if (pendingUpdates > 0) break;
        activeBatchId++;
        pendingUpdates = numWorkers;
        currentTotalEnergy = 0;
        workers.forEach(worker => {
            const buffer = ensureWorkerBuffer(worker);
            worker.postMessage({ type: 'update', batchId: activeBatchId, dt: FIXED_DT, buffer }, [buffer]);
        });
        accumulator -= FIXED_DT;
    }
    
    const transitionSpeed = 5.0;
    const targetTransition = showOverlay ? 1 : 0;
    overlayTransition = lerp(overlayTransition, targetTransition, frameTime * transitionSpeed);
    
    if ((currentTime - lastUiUpdate) >= UI_UPDATE_INTERVAL_MS) {
        lastUiUpdate = currentTime;

        if (showOverlay) {
            let sumX = 0;
            let sumY = 0;
            let sumDist = 0;
            for (let i = 0; i < NUM_SYSTEMS; i++) {
                const b = systemStates[i].ball;
                const x = b.x;
                const y = b.y;
                sumX += x;
                sumY += y;
                sumDist += Math.sqrt(x * x + y * y);
            }

            const invCount = 1 / NUM_SYSTEMS;
            avgXEl.textContent = (sumX * invCount).toFixed(1);
            avgYEl.textContent = (sumY * invCount).toFixed(1);
            avgDistEl.textContent = (sumDist * invCount).toFixed(1);
        }

        totalEEl.textContent = (displayedTotalEnergy / 1000).toFixed(1) + "k";

        const dev = totalInitialEnergy > 0 ? ((displayedTotalEnergy - totalInitialEnergy) / totalInitialEnergy) * 100 : 0;
        const devDisplay = Math.abs(dev) < 0.001 ? "0.00" : (dev > 0 ? "+" : "") + dev.toPrecision(3);
        deviationEl.textContent = devDisplay + "%";

        updateGraph(displayedTotalEnergy);
    }

    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const t = overlayTransition;
    const systemScale = lerp(layoutScale, overlayScale, t);

    ctx.globalAlpha = lerp(1.0, OVERLAY_ALPHA, t);

    // Precompute per-system draw positions for this frame (avoid per-pass recalculation/allocations).
    for (let i = 0; i < NUM_SYSTEMS; i++) {
        drawCx[i] = lerp(gridCx[i], overlayCenterX, t);
        drawCy[i] = lerp(gridCy[i], overlayCenterY, t);
    }

    // Pass 1: Draw all container circles and crosshairs
    for (let i = 0; i < NUM_SYSTEMS; i++) {
        const s = systemStates[i];
        ctx.setTransform(systemScale, 0, 0, systemScale, drawCx[i], drawCy[i]);

        ctx.beginPath();
        ctx.arc(0, 0, CONTAINER_RADIUS, 0, TWO_PI);
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#555';
        ctx.stroke();

        ctx.rotate(s.container.angle);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-CONTAINER_RADIUS, 0);
        ctx.lineTo(CONTAINER_RADIUS, 0);
        ctx.moveTo(0, -CONTAINER_RADIUS);
        ctx.lineTo(0, CONTAINER_RADIUS);
        ctx.stroke();
    }

    // Pass 2: Draw all trails
    if (showTrails) {
        for (let i = 0; i < NUM_SYSTEMS; i++) {
            const s = systemStates[i];
            pushTrailPoint(s, s.ball.x, s.ball.y);

            const size = s.trailSize;
            if (size < 2) continue;

            ctx.setTransform(systemScale, 0, 0, systemScale, drawCx[i], drawCy[i]);

            ctx.beginPath();
            ctx.strokeStyle = trailColors[i];
            ctx.lineWidth = 3;

            let idx = s.trailHead - size;
            if (idx < 0) idx += TRAIL_LENGTH;
            ctx.moveTo(s.trailX[idx], s.trailY[idx]);

            for (let k = 1; k < size; k++) {
                idx++;
                if (idx === TRAIL_LENGTH) idx = 0;
                ctx.lineTo(s.trailX[idx], s.trailY[idx]);
            }

            ctx.stroke();
        }
    }

    // Pass 3: Draw all balls
    ctx.fillStyle = '#eee';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 3;

    for (let i = 0; i < NUM_SYSTEMS; i++) {
        const s = systemStates[i];
        ctx.setTransform(systemScale, 0, 0, systemScale, drawCx[i], drawCy[i]);
        ctx.translate(s.ball.x, s.ball.y);
        ctx.rotate(s.ball.angle);

        ctx.beginPath();
        ctx.arc(0, 0, BALL_RADIUS, 0, TWO_PI);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(BALL_RADIUS, 0);
        ctx.stroke();
    }

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.globalAlpha = 1.0;
    requestAnimationFrame(loop);
}

function toggleTrails() {
    showTrails = !showTrails;
    if (!showTrails) clearTrails();
}

function toggleOverlay() {
    showOverlay = !showOverlay;
    overlayStatsEl.style.display = showOverlay ? 'block' : 'none';
    lastUiUpdate = 0;
}

// Workers will initialize and start automatically

</script>
</body>
</html>