<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parallel Rigid Body Simulation (64x)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-radius: 4px;
            background-color: #222;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            min-width: 250px;
            backdrop-filter: blur(4px);
        }

        h1 {
            font-size: 16px;
            margin: 0 0 10px 0;
            color: #4db8ff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            margin-bottom: 5px;
            font-family: 'Courier New', monospace;
        }

        .label { color: #888; }
        .value { color: #fff; font-weight: bold; }

        #energy-graph {
            margin-top: 10px;
            width: 100%;
            height: 60px;
            background: #111;
            border: 1px solid #333;
            position: relative;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            display: flex;
            gap: 10px;
        }

        button {
            pointer-events: auto;
            background: #444;
            color: white;
            border: 1px solid #666;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            transition: background 0.2s;
        }

        button:hover { background: #555; }
        button:active { background: #4db8ff; border-color: #4db8ff; }

    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>Multiverse Stats (64x)</h1>
        <div class="stat-row">
            <span class="label">Systems Active:</span>
            <span class="value">64</span>
        </div>
        <div class="stat-row">
            <span class="label">Workers:</span>
            <span class="value" id="worker-count">0</span>
        </div>
        <div class="stat-row">
            <span class="label">Total Energy (Sum):</span>
            <span class="value" id="total-e">0.00</span>
        </div>
        <div class="stat-row">
            <span class="label">Avg Deviation:</span>
            <span class="value" id="deviation" style="color: #0f0">0.00%</span>
        </div>
        <canvas id="energy-graph"></canvas>
        
        <div id="overlay-stats" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #333;">
            <div class="stat-row">
                <span class="label">Avg Height (Y):</span>
                <span class="value" id="avg-y">0.0</span>
            </div>
            <div class="stat-row">
                <span class="label">Avg Displacement (X):</span>
                <span class="value" id="avg-x">0.0</span>
            </div>
            <div class="stat-row">
                <span class="label">Avg Distance:</span>
                <span class="value" id="avg-dist">0.0</span>
            </div>
        </div>
    </div>

    <canvas id="simCanvas"></canvas>

    <div class="controls">
        <button onclick="resetAll()">Reset Multiverse</button>
        <button onclick="toggleTrails()">Toggle Trails</button>
        <button onclick="toggleOverlay()">Toggle Overlay</button>
    </div>

<script>
/**
 * Parallel Precision Physics Engine with Web Workers
 * Simulates 64 independent rigid body systems across multiple CPU cores
 */

const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const graphCanvas = document.getElementById('energy-graph');
const graphCtx = graphCanvas.getContext('2d');

// --- Constants ---
const NUM_SYSTEMS = 64;
const CONTAINER_RADIUS = 300;
const BALL_RADIUS = 30;

// --- Worker Pool ---
const numWorkers = navigator.hardwareConcurrency || 4;
const workers = [];
const systemStates = Array(NUM_SYSTEMS).fill(null).map((_, i) => ({
    id: i,
    ball: {x: 0, y: -220, angle: 0},
    container: {angle: 0},
    history: []
}));

document.getElementById('worker-count').innerText = numWorkers;

// Distribute systems across workers
const systemsPerWorker = Math.ceil(NUM_SYSTEMS / numWorkers);
for (let w = 0; w < numWorkers; w++) {
    const worker = new Worker('physics-worker.js');
    const startId = w * systemsPerWorker;
    const endId = Math.min(startId + systemsPerWorker, NUM_SYSTEMS);
    const systemIds = [];
    for (let i = startId; i < endId; i++) {
        systemIds.push(i);
    }
    
    worker.systemIds = systemIds;
    worker.onmessage = handleWorkerMessage;
    worker.postMessage({ type: 'init', data: { systemIds } });
    workers.push(worker);
}

// Fixed timestep variables
let lastTime = performance.now();
let accumulator = 0;
const FIXED_DT = 1/180;
const MAX_FRAME_TIME = 0.25;

let showTrails = true;
let showOverlay = false;
let overlayTransition = 0;
let totalInitialEnergy = 0;
let currentTotalEnergy = 0;
let displayedTotalEnergy = 0;
let energyHistory = [];
let layoutScale = 1;
let overlayScale = 1;
let pendingUpdates = 0;
let initializedWorkers = 0;
let isReady = false;

function handleWorkerMessage(e) {
    const { type, states, totalEnergy } = e.data;
    
    if (type === 'initialized') {
        initializedWorkers++;
        if (initializedWorkers === numWorkers) {
            isReady = true;
            resetAll();
            requestAnimationFrame(loop);
        }
    } else if (type === 'updated') {
        states.forEach(state => {
            systemStates[state.id].ball = state.ball;
            systemStates[state.id].container = state.container;
            systemStates[state.id].initialEnergy = state.initialEnergy;
        });
        currentTotalEnergy += totalEnergy;
        pendingUpdates--;
        if (pendingUpdates === 0) {
            displayedTotalEnergy = currentTotalEnergy;
        }
    } else if (type === 'reset') {
        states.forEach(state => {
            systemStates[state.id].ball = state.ball;
            systemStates[state.id].container = state.container;
            systemStates[state.id].initialEnergy = state.initialEnergy;
            systemStates[state.id].history = [];
        });
        currentTotalEnergy += totalEnergy;
        pendingUpdates--;
        
        if (pendingUpdates === 0) {
            totalInitialEnergy = systemStates.reduce((sum, s) => sum + (s.initialEnergy || 0), 0);
            displayedTotalEnergy = currentTotalEnergy;
        }
    }
}

function lerp(a, b, t) {
    return a + (b - a) * t;
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    graphCanvas.width = graphCanvas.offsetWidth;
    graphCanvas.height = graphCanvas.offsetHeight;
    
    if (energyHistory.length > graphCanvas.width) {
        energyHistory = energyHistory.slice(energyHistory.length - graphCanvas.width);
    }
    
    const cols = 8; 
    const rows = 8;
    const cellUnitSize = (CONTAINER_RADIUS * 2) * 1.1;
    
    const scaleH = window.innerHeight / (rows * cellUnitSize);
    const scaleW = window.innerWidth / (cols * cellUnitSize);
    layoutScale = Math.min(scaleH, scaleW) * 0.95;
    
    const overlayUnitSize = (CONTAINER_RADIUS * 2) * 1.05;
    const overlayScaleH = window.innerHeight / overlayUnitSize;
    const overlayScaleW = window.innerWidth / overlayUnitSize;
    overlayScale = Math.min(overlayScaleH, overlayScaleW) * 0.98;
}
window.addEventListener('resize', resize);
resize();

function resetAll() {
    pendingUpdates = numWorkers;
    currentTotalEnergy = 0;
    workers.forEach(worker => {
        worker.postMessage({ type: 'reset' });
    });
    energyHistory = [];
}

function updateGraph(currentTotal) {
    if (!totalInitialEnergy) return;
    
    energyHistory.push(currentTotal);
    if (energyHistory.length > graphCanvas.width) energyHistory.shift();
    
    const w = graphCanvas.width;
    const h = graphCanvas.height;
    
    graphCtx.clearRect(0, 0, w, h);
    
    graphCtx.beginPath();
    graphCtx.strokeStyle = '#444';
    graphCtx.setLineDash([5, 5]);
    graphCtx.moveTo(0, h/2);
    graphCtx.lineTo(w, h/2);
    graphCtx.stroke();
    graphCtx.setLineDash([]);
    
    graphCtx.beginPath();
    graphCtx.strokeStyle = '#0f0';
    graphCtx.lineWidth = 2;
    const scale = 5000;
    
    for (let i = 0; i < energyHistory.length; i++) {
        const val = energyHistory[i];
        const diff = (val - totalInitialEnergy) / totalInitialEnergy;
        const y = (h/2) - (diff * (h/2) * scale);
        if(i===0) graphCtx.moveTo(i, y);
        else graphCtx.lineTo(i, y);
    }
    graphCtx.stroke();
}

function loop() {
    const currentTime = performance.now();
    let frameTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;
    
    if (frameTime > MAX_FRAME_TIME) frameTime = MAX_FRAME_TIME;
    
    accumulator += frameTime;
    
    while (accumulator >= FIXED_DT) {
        // Don't send updates while waiting for responses (reset or update)
        if (pendingUpdates > 0) break;
        pendingUpdates = numWorkers;
        currentTotalEnergy = 0;
        workers.forEach(worker => {
            worker.postMessage({ type: 'update', data: { dt: FIXED_DT } });
        });
        accumulator -= FIXED_DT;
    }
    
    const transitionSpeed = 5.0;
    const targetTransition = showOverlay ? 1 : 0;
    overlayTransition = lerp(overlayTransition, targetTransition, frameTime * transitionSpeed);
    
    // Show/hide overlay stats
    document.getElementById('overlay-stats').style.display = showOverlay ? 'block' : 'none';
    
    // Calculate overlay statistics
    if (showOverlay) {
        let sumX = 0, sumY = 0, sumDist = 0;
        let count = 0;
        systemStates.forEach(s => {
            if (s.ball && s.ball.x !== undefined && s.ball.y !== undefined) {
                sumX += s.ball.x;
                sumY += s.ball.y;
                sumDist += Math.sqrt(s.ball.x * s.ball.x + s.ball.y * s.ball.y);
                count++;
            }
        });
        if (count > 0) {
            document.getElementById('avg-x').innerText = (sumX / count).toFixed(1);
            document.getElementById('avg-y').innerText = (sumY / count).toFixed(1);
            document.getElementById('avg-dist').innerText = (sumDist / count).toFixed(1);
        }
    }
    
    document.getElementById('total-e').innerText = (displayedTotalEnergy / 1000).toFixed(1) + "k";
    
    const dev = totalInitialEnergy > 0 ? ((displayedTotalEnergy - totalInitialEnergy) / totalInitialEnergy) * 100 : 0;
    const devDisplay = Math.abs(dev) < 0.001 ? "0.00" : (dev > 0 ? "+" : "") + dev.toPrecision(3);
    document.getElementById('deviation').innerText = devDisplay + "%";
    
    updateGraph(displayedTotalEnergy);
    
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const rows = 8;
    const cols = 8;
    const cellW = canvas.width / cols;
    const cellH = canvas.height / rows;
    
    const alpha = lerp(1.0, Math.sqrt(1.0 / NUM_SYSTEMS), overlayTransition);
    ctx.globalAlpha = alpha;
    
    // Helper to calculate position and scale for a system
    function getSystemTransform(i) {
        const col = i % cols;
        const row = Math.floor(i / cols);
        const gridX = col * cellW + cellW/2;
        const gridY = row * cellH + cellH/2;
        const overlayX = canvas.width / 2;
        const overlayY = canvas.height / 2;
        return {
            cx: lerp(gridX, overlayX, overlayTransition),
            cy: lerp(gridY, overlayY, overlayTransition),
            scale: lerp(layoutScale, overlayScale, overlayTransition)
        };
    }
    
    // Pass 1: Draw all container circles and crosshairs
    systemStates.forEach((s, i) => {
        const { cx, cy, scale } = getSystemTransform(i);
        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(scale, scale);
        ctx.rotate(s.container.angle);
        
        ctx.beginPath();
        ctx.arc(0, 0, CONTAINER_RADIUS, 0, Math.PI * 2);
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#555';
        ctx.stroke();
        
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-CONTAINER_RADIUS, 0);
        ctx.lineTo(CONTAINER_RADIUS, 0);
        ctx.moveTo(0, -CONTAINER_RADIUS);
        ctx.lineTo(0, CONTAINER_RADIUS);
        ctx.stroke();
        
        ctx.restore();
    });
    
    // Pass 2: Draw all trails
    if (showTrails) {
        systemStates.forEach((s, i) => {
            s.history.push({x: s.ball.x, y: s.ball.y});
            if (s.history.length > 200) s.history.shift();
            
            const { cx, cy, scale } = getSystemTransform(i);
            ctx.save();
            ctx.translate(cx, cy);
            ctx.scale(scale, scale);
            
            ctx.beginPath();
            ctx.strokeStyle = `hsl(${(i * 360/NUM_SYSTEMS)}, 70%, 60%)`;
            ctx.lineWidth = 3;
            for (let k = 0; k < s.history.length - 1; k++) {
                ctx.moveTo(s.history[k].x, s.history[k].y);
                ctx.lineTo(s.history[k+1].x, s.history[k+1].y);
            }
            ctx.stroke();
            
            ctx.restore();
        });
    }
    
    // Pass 3: Draw all balls
    systemStates.forEach((s, i) => {
        const { cx, cy, scale } = getSystemTransform(i);
        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(scale, scale);
        ctx.translate(s.ball.x, s.ball.y);
        ctx.rotate(s.ball.angle);
        
        ctx.beginPath();
        ctx.arc(0, 0, BALL_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = '#eee';
        ctx.fill();
        
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(BALL_RADIUS, 0);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        ctx.restore();
    });
    
    ctx.globalAlpha = 1.0;
    requestAnimationFrame(loop);
}

function toggleTrails() {
    showTrails = !showTrails;
    if(!showTrails) systemStates.forEach(s => s.history = []);
}

function toggleOverlay() {
    showOverlay = !showOverlay;
}

// Workers will initialize and start automatically

</script>
</body>
</html>